Projet "Dernier Metro Paris" — Brief (chat)
 
Contexte
- Objectif: aider un usager nocturne a savoir s'il attrapera le dernier metro depuis une station donnee.
- Portee J1: API minimale + Docker. (Swagger sera ajoute l'apres-midi.)
 
MVP — Endpoints
1) GET /health -> 200 { status: "ok" }
2) GET /next-metro?station=NAME -> 200 JSON
   Reponse attendue (exemple):
   { "station": "Chatelet", "line": "M1", "headwayMin": 3, "nextArrival": "12:34", "isLast": false, "tz": "Europe/Paris" }
 
Erreurs
- 400 si station manquante -> { error: "missing station" }
- 404 JSON pour routes inconnues -> { error: "not found" }
 
Regles metier (simplifiees)
- Service metro: 05:30 -> 01:15 (fictif pour le cours).
- headwayMin = 3 pendant la plage de service.
- isLast = true entre 00:45 et 01:15 (dernieres rames).
- En dehors du service, renvoyer 200 avec { service: "closed" } OU 204 sans corps (au choix, documentez dans README).
 
Contraintes techniques
- Reponses JSON uniquement via res.status(...).json({...}).
- Logs par requete: methode, chemin, status, duree.
- PORT via variable d'environnement (process.env.PORT || 3000).
- Containerisation via Dockerfile.v1 + .dockerignore.
 
Validation rapide
- curl -i http://localhost:3000/health
- curl -s "http://localhost:3000/next-metro?station=Chatelet"
 
Livrables J1 (Partie A)
- server.js, package.json, Dockerfile.v1, .dockerignore, README.md
- Capture /health + extrait de logs
 
Avertissement
- Les horaires sont simules a des fins pedagogiques (pas de donnees RATP temps reel).

Challenge bonus (pour les rapides) — 3 points max
Trois mini-défis indépendants, en continuité directe du MVP. 1 point par défi validé.
Défi A — Rendre la fenêtre et la fréquence configurables via ENV (1 pt)
Ajouter des variables d'environnement (avec valeurs par défaut si absentes):
HEADWAY_MIN (par défaut: 3)
LAST_WINDOW_START au format HH:MM (par défaut: 00:45)
SERVICE_END au format HH:MM (par défaut: 01:15)
Utiliser ces variables dans le calcul nextArrival.
Critères de validation:
En lançant avec HEADWAY_MIN=5, la réponse expose headwayMin: 5 et les horaires sont espacés de 5 min.
En lançant avec LAST_WINDOW_START=00:40, isLast devient true plus tôt.
Défi B — N prochains passages (1 pt)
Étendre GET /next-metro?station=NAME&n=3 pour retourner les N prochains passages (limiter N entre 1 et 5).
Réponse proposée:
Critères de validation:
n=3 renvoie exactement 3 horaires espacés de headwayMin.
Si n est absent, comportement MVP inchangé (1 seul horaire) OU n=1 par défaut (au choix, mais documenter).
Défi C — Validation station + suggestions (1 pt)
Si station est inconnue, renvoyer 404 avec:
Implémenter une suggestion simple par correspondance préfixe/substring dans une petite liste locale de stations (5–10 entrées suffisent). Optionnel: charger depuis un CSV plus tard.
Critères de validation:
station=Chate retourne un 404 avec suggestions contenant "Chatelet".
station=Zzz retourne un 404 avec suggestions: [].
Astuce: conservez des réponses strictement JSON, loguez les tentatives (méthode, chemin, statut, durée), et documentez clairement tout nouveau paramètre (ENV ou query) dans le README.
{ "error": "unknown station", "suggestions": ["Chatelet", "Concorde"] }
{"station": "Chatelet","line": "M1","headwayMin": 3,"tz": "Europe/Paris","arrivals": [{ "time": "12:34", "isLast": false },{ "time": "12:37", "isLast": false },{ "time": "12:40", "isLast": false }]}
